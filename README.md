# -3.-
Задание № 3. Разработайте базовый алгоритм управления для БПЛА
Инструкция:
Шаг 1: Выберите конфигурацию мультироторного дрона (например, квадрокоптер, hexacopter) и определите параметры, такие как масса, размеры, типы двигателей.
Шаг 2: Исследуйте основные принципы управления мультироторными дронами, включая роли, высоту полета, крен, тангаж и рысканье.
Шаг 3: Разработайте базовый алгоритм управления, включающий элементы стабилизации и навигации. Рассмотрите использование ПИД-регуляторов для коррекции ошибок в угловых ориентациях и высоте полета.
Шаг 4: Опишите входные данные, которые необходимы для алгоритма (например, данные с гироскопов, акселерометров, высотомеров) и выходные данные (управляющие сигналы для моторов).
Шаг 5: Проведите тестирование базового алгоритма в симуляторе или на реальном дроне. Оцените его способность стабилизировать полет и реагировать на изменения окружающей среды.
Шаг 6: Предложите возможные улучшения или дополнения к базовому алгоритму, чтобы учитывать различные условия полета.
Шаг 7: Продемонстрируйте работу алгоритма в различных сценариях, таких как изменение высоты, повороты, и следование заданному маршруту.
Шаг 8: Сформулируйте выводы о разработанном базовом алгоритме, оцените его эффективность и применимость в базовых сценариях полета.
Шаг 9: Загрузите описание базового алгоритма в репозиторий на платформе GitHub.
Шаг 10: Выложите ссылку на репозиторий в LMS Odin.





Для описания квадрокоптера, рассмотрим популярную модель Chimera 9. Приведем параметры и комплектующие этого дрона, после чего перейдем к реализации алгоритма управления и визуализации полета.

### Шаг 1: Выбор конфигурации квадрокоптера

#### Параметры квадрокоптера Chimera 9:
- **Масса**: 300 г (без батареи), 500-600 г (с батареей)
- **Размеры**: Диагональ между моторами - 9 дюймов (около 228 мм)
- **Тип двигателей**: Бесколлекторные двигатели
  - Один из популярных двигателей для этой модели - iFlight XING 2306 1700KV.
- **Батарея**: Литий-полимерная (Li-Po) аккумуляторная батарея 3S 11.1V или 4S 14.8V на 1300-1500 мА·ч
- **Контроллеры**: Электронные регуляторы скорости (ESC) - обычно 35А-60А

#### Примерная конфигурация:
- **Рама**: iFlight Chimera 9 9" Frame
- **Двигатели**: iFlight XING 2306 1700KV
- **ESC**: iFlight SucceX-E 45A 4-in-1
- **Полетный контроллер**: iFlight SucceX-E F7
- **Батарея**: Li-Po 4S 1500mAh

### Шаг 2: Основные принципы управления мультироторными дронами

Управление квадрокоптером имеет несколько важных аспектов:
1. **Ролл (Roll)**: Наклонение вперед/назад
2. **Крен (Pitch)**: Наклонение влево/вправо
3. **Рысканье (Yaw)**: Поворот вокруг вертикальной оси
4. **Газ (Throttle)**: Контроль высоты

Каждое из этих действий контролируется изменением скорости вращения одного или нескольких моторов.

### Шаг 3: Разработка базового алгоритма управления

Для стабилизации и навигации квадрокоптера можем использовать ПИД-регуляторы. ПИД-регуляторы помогают компенсировать отклонения от заданного положения и скорости.

#### Алгоритм стабилизации:
1. Получаем данные с датчиков (гироскопы и акселерометры).
2. Вычисляем ошибки текущих угловых ориентаций относительно заданных значений.
3. Применяем ПИД-регуляторы для вычисления корректирующих сигналов для моторов.

### Алгоритм управления квадрокоптером
import numpy as np
import matplotlib.pyplot as plt

# Параметры квадрокоптера
dt = 0.1  # шаг времени
total_time = 100  # общее время
t = np.arange(0, total_time, dt)

# Функции ПИД-регуляторов для стабильности и управления
def pid_controller(error, prev_error, integral, kp, ki, kd):
    integral += error * dt
    derivative = (error - prev_error) / dt
    output = kp * error + ki * integral + kd * derivative
    return output, integral

# Коэффициенты ПИД-регуляторов
kp_roll, ki_roll, kd_roll = 1.0, 0.3, 0.05
kp_pitch, ki_pitch, kd_pitch = 1.0, 0.3, 0.05
kp_yaw, ki_yaw, kd_yaw = 1.0, 0.3, 0.05

# Начальные условия
position = np.array([0.0, 0.0, 0.0])  # [x, y, z]
velocity = np.array([0.0, 0.0, 0.0])  # [vx, vy, vz]
angles = np.array([0.0, 0.0, 0.0])  # [roll, pitch, yaw]

# Начальные ошибки для ПИД-регуляторов
prev_error_roll, integral_roll = 0, 0
prev_error_pitch, integral_pitch = 0, 0
prev_error_yaw, integral_yaw = 0, 0

# Массивы для хранения траекторий
positions = []

# Флаг для этапов перемещения
phase = 0

for time in t:
    if phase == 0:  # Подъем с одновременным смещением вправо
        desired_roll = -5  # наклон вправо
        desired_pitch = 0  # без изменения
        desired_yaw = 0  # без изменения
        target_throttle = 1.5 if position[2] < 50 else 1.0  # поддержание высоты 50м
        if position[2] >= 50:
            phase = 1
    elif phase == 1:  # Прямое движение вперед
        desired_roll = 0  # наклон вправо
        desired_pitch = -5  # наклон вперед
        desired_yaw = 0  # без изменения
        target_throttle = 1.0  # поддержание высоты
        if position[0] >= 50:  # если вперед на 50 метров
            phase = 2
    elif phase == 2:  # Сдвиг влево
        desired_roll = 5  # наклон влево
        desired_pitch = 0  # без изменения
        desired_yaw = 0  # без изменения
        target_throttle = 1.0  # поддержание высоты

    # Рассчитываем ошибки для ПИД-регуляторов
    error_roll = desired_roll - angles[0]
    error_pitch = desired_pitch - angles[1]
    error_yaw = desired_yaw - angles[2]

    roll_output, integral_roll = pid_controller(error_roll, prev_error_roll, integral_roll, kp_roll, ki_roll, kd_roll)
    pitch_output, integral_pitch = pid_controller(error_pitch, prev_error_pitch, integral_pitch, kp_pitch, ki_pitch, kd_pitch)
    yaw_output, integral_yaw = pid_controller(error_yaw, prev_error_yaw, integral_yaw, kp_yaw, ki_yaw, kd_yaw)

    prev_error_roll = error_roll
    prev_error_pitch = error_pitch
    prev_error_yaw = error_yaw

    # Обновляем углы
    angles += np.array([roll_output, pitch_output, yaw_output]) * dt

    # Обновляем скорость и позицию
    velocity += np.array([np.sin(-np.radians(angles[1])), np.sin(np.radians(angles[0])), target_throttle]) * dt
    position += velocity * dt

    # Сохраняем позицию
    positions.append(position.copy())

positions = np.array(positions)

# Рисуем траекторию
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], label='Траектория коптера')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
plt.show()
 
В этом коде создается класс для квадрокоптера и отдельный класс для ПИД-регулятора. Используя эти классы, мы можем управлять ориентацией и высотой квадрокоптера путем изменения скоростей вращения моторов.  
Для визуализации полета квадрокоптера используется библиотека `matplotlib`. Эта часть кода создает 3D-график траектории полета, обновляя его в реальном времени при помощи функции `FuncAnimation`.
